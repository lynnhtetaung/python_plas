<h2 id="statement">23</h2>
Fill in Blanks 
<h2 id="code">The Source Code</h2>
<pre class="prettyprint" id="scoring-res"># A quick-demo of Dijkstra Algorithm Usage
# Python program for Dijkstra's single source shortest path algorithm.
# The program is for adjacency matrix representation of the graph 
  
# Library for INT_MAX 
import sys 
   
class Graph(): 
   
    def __init__(self, vertices): 
        self.V = vertices 
        self.graph = [[0 for column in range(vertices)]  
                    for row in range(vertices)] 
   
    def printSolution(self, dist): 
        print ("Vertex tDistance from Source") 
        for node in range(self.V): 
            print (node, "t", dist[node]) 
   
    # A utility function to find the vertex with minimum distance value, from the set of vertices  
    # not yet included in shortest path tree 
    def minDistance(self, dist, sptSet): 
   
        # Initilaize minimum distance for next node 
        min = sys.maxsize 
   
        # Search not nearest vertex not in the shortest path tree 
        for v in range(self.V): 
            if dist[v] < min and sptSet[v] == False: 
                min = dist[v] 
                min_index = v 
   
        return min_index 
   
    # Funtion that implements Dijkstra's single source shortest path algorithm for a graph represented  
    # using adjacency matrix representation 
    def dijkstra(self, src): 
   
        dist = [sys.maxsize] * self.V 
        dist[src] = 0
        sptSet = [False] * self.V 
   
        for cout in range(self.V): 
   
            # Pick the minimum distance vertex from the set of vertices not yet processed.  
            # u is always equal to src in first iteration 
            u = self.minDistance(dist, sptSet) 
   
            # Put the minimum distance vertex in the shotest path tree 
            sptSet[u] = True
   
            # Update dist value of the adjacent vertices of the picked vertex only if the current  
            # distance is greater than new distance and the vertex in not in the shotest path tree 
            for v in range(self.V): 
                if (self.graph[u][v] > 0 and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]): 
                    dist[v] = dist[u] + self.graph[u][v] 
   
        self.printSolution(dist) 
   
g = Graph(9) 
g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], 
        [4, 0, 8, 0, 0, 0, 0, 11, 0], 
        [0, 8, 0, 7, 0, 4, 0, 0, 2], 
        [0, 0, 7, 0, 9, 14, 0, 0, 0], 
        [0, 0, 0, 9, 0, 10, 0, 0, 0], 
        [0, 0, 4, 14, 10, 0, 2, 0, 0], 
        [0, 0, 0, 0, 0, 2, 0, 1, 6], 
        [8, 11, 0, 0, 0, 0, 1, 0, 7], 
        [0, 0, 2, 0, 0, 0, 6, 7, 0] 
        ]; 
   
g.dijkstra(0); 
  
The output of this program are:
Vertex tDistance from Source
0 t 0
1 t 4
2 t <input size=2 ans="4679b1f742417e874f7195e47deac6b9346c757d4fc3360a5a3e4597903fc269" placeholder=1></input>
3 t <input size=2 ans="7a784ccdee450fb11c42a889538b1f0caea1373874102def184b6e93d07b563d" placeholder=2></input>
4 t <input size=2 ans="35542e0fd2a590a9361f136c13fa9e2112cba234c1eb5f6e3596d45c391fb971" placeholder=3></input>
5 t 11
6 t <input size=2 ans="ee7e0264108d8ba198b1052eaa9f14a580145e8307c6449a8a81c82fe347ad8b" placeholder=4></input>
7 t 8
8 t <input size=2 ans="2465f1df94cdabdd5557df6b874fb25187a92a22a8610420dd4de353be3c57cd" placeholder=5></input>


</pre>
<h2 id="answer">Answer</h2>
<a class="btn" href="javascript:newScoring('Python_VTP_algorithm')">Answer</a>
<script type="text/javascript">
$(function(){
 prettyPrint();
});
</script>